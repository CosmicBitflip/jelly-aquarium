```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>3D Jellyfish Aquarium</title>
    <style>
        body { margin: 0; overflow: hidden; background: #001122; }
    </style>
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.178.0/build/three.module.js",
                "three/examples/": "https://cdn.jsdelivr.net/npm/three@0.178.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>
    <script type="module">
        import * as THREE from 'three';
        import { EffectComposer } from 'three/examples/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/examples/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/examples/postprocessing/UnrealBloomPass.js';
        console.log("Three loaded", THREE ? "Yes" : "No");

        const isMobile = window.innerWidth < 600;
        const scaleFactor = isMobile ? 0.5 : 1;
        const cameraZ = isMobile ? 120 : 80;
        const numJellies = 98; // Set to 98 as requested
        const formationDuration = 10; // Seconds text visible
        const numBubbles = 200; // Number of bubbles

        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x001122, 0.005); // Underwater haze

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = cameraZ;

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        const composer = new EffectComposer(renderer);
        const renderPass = new RenderPass(scene, camera);
        composer.addPass(renderPass);
        const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 0.5, 0.4, 0.85);
        composer.addPass(bloomPass);

        // Enhanced water background
        function createWaterBackground() {
            const geometry = new THREE.PlaneGeometry(500, 500);
            const material = new THREE.ShaderMaterial({
                uniforms: {
                    time: { value: 0.0 },
                    resolution: { value: new THREE.Vector2(window.innerWidth, window.innerHeight) }
                },
                vertexShader: `
                    varying vec2 vUv;
                    uniform float time;
                    void main() {
                        vUv = uv;
                        vec3 pos = position;
                        pos.z += sin(pos.x * 0.05 + time * 0.5) * 3.0 + cos(pos.y * 0.05 + time * 0.3) * 2.0;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
                    }
                `,
                fragmentShader: `
                    varying vec2 vUv;
                    uniform vec2 resolution;
                    uniform float time;
                    float noise(vec2 p) {
                        return sin(p.x * 10.0 + time) * sin(p.y * 10.0 + time) * 0.1;
                    }
                    void main() {
                        vec2 st = gl_FragCoord.xy / resolution;
                        vec3 color = mix(vec3(0.0, 0.1, 0.3), vec3(0.0, 0.3, 0.6), st.y);
                        color += noise(st * 5.0) + noise(st * 10.0) * 0.5;
                        gl_FragColor = vec4(color, 0.85);
                    }
                `,
                transparent: true
            });
            const plane = new THREE.Mesh(geometry, material);
            plane.position.z = -50;
            plane.rotation.x = -0.1;
            scene.add(plane);
            return material;
        }

        const waterMaterial = createWaterBackground();

        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);

        const hemiLight = new THREE.HemisphereLight(0x00aaff, 0x001122, 0.8);
        scene.add(hemiLight);

        const pointLight = new THREE.PointLight(0xffffff, 1, 500);
        pointLight.position.set(0, 0, 100);
        scene.add(pointLight);

        // Round bubbles with canvas texture
        let bubbles, bubbleVelocities = [];
        function initBubbles() {
            const canvas = document.createElement('canvas');
            canvas.width = 32;
            canvas.height = 32;
            const ctx = canvas.getContext('2d');
            ctx.beginPath();
            ctx.arc(16, 16, 16, 0, Math.PI * 2);
            ctx.fillStyle = '#fff';
            ctx.fill();
            const texture = new THREE.CanvasTexture(canvas);

            const geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(numBubbles * 3);
            for (let i = 0; i < numBubbles; i++) {
                positions[i * 3] = (Math.random() * 200 - 100) * scaleFactor;
                positions[i * 3 + 1] = (Math.random() * -150 - 50) * scaleFactor;
                positions[i * 3 + 2] = (Math.random() * 100 - 50) * scaleFactor;
                bubbleVelocities[i] = (20 + Math.random() * 10) * scaleFactor;
            }
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            const material = new THREE.PointsMaterial({
                map: texture,
                transparent: true,
                alphaTest: 0.1,
                size: 2 * scaleFactor,
                blending: THREE.AdditiveBlending
            });
            bubbles = new THREE.Points(geometry, material);
            scene.add(bubbles);
        }

        function updateBubbles(dt) {
            const positions = bubbles.geometry.attributes.position.array;
            for (let i = 0; i < numBubbles; i++) {
                positions[i * 3 + 1] += bubbleVelocities[i] * dt;
                positions[i * 3] += Math.sin(Date.now() * 0.001 + i) * 0.1 * scaleFactor;
                if (positions[i * 3 + 1] > 100 * scaleFactor) {
                    positions[i * 3 + 1] = -100 * scaleFactor - Math.random() * 50 * scaleFactor;
                }
            }
            bubbles.geometry.attributes.position.needsUpdate = true;
        }

        initBubbles();

        const jellyfishes = [];
        let formationMode = false;
        let formationTargets = [];
        let formationTimer = 0;
        let touchStartTime = 0;

        // Pixel font positions (unchanged)
        const letterPositions = {
            'H': [[0,4],[2,4],[0,3],[2,3],[0,2],[1,2],[2,2],[0,1],[2,1],[0,0],[2,0]],
            'A': [[0,4],[1,4],[2,4],[0,3],[2,3],[0,2],[1,2],[2,2],[0,1],[2,1],[0,0],[2,0]],
            'P': [[0,4],[1,4],[2,4],[0,3],[2,3],[0,2],[1,2],[2,2],[0,1],[0,0]],
            'Y': [[0,4],[2,4],[0,3],[2,3],[1,2],[1,1],[1,0]],
            'B': [[0,4],[1,4],[2,4],[0,3],[2,3],[0,2],[1,2],[2,2],[0,1],[2,1],[0,0],[1,0],[2,0]],
            'D': [[0,4],[1,4],[2,4],[0,3],[2,3],[0,2],[2,2],[0,1],[2,1],[0,0],[1,0],[2,0]],
            '!': [[1,4],[1,3],[1,2],[1,0]]
        };

        const lines = ['HAPPY', 'BDAY!'];
        const pixelSpacing = 10;
        const letterSpacing = 40;
        const lineSpacing = 60;
        const initialOffsetY = 40;
        const yCentering = 40;
        const zDepth = -20;
        let offsetY = initialOffsetY * scaleFactor;
        lines.forEach((line, lineIndex) => {
            let offsetX = - (line.length * letterSpacing / 2) * scaleFactor;
            line.split('').forEach(char => {
                const positions = letterPositions[char.toUpperCase()] || [];
                positions.forEach(([x, y]) => {
                    formationTargets.push(new THREE.Vector3((offsetX + x * pixelSpacing) * scaleFactor, (offsetY + y * pixelSpacing - yCentering) * scaleFactor, zDepth * scaleFactor));
                });
                offsetX += letterSpacing * scaleFactor;
            });
            offsetY -= lineSpacing * scaleFactor;
        });
        while (formationTargets.length < numJellies) {
            formationTargets.push(new THREE.Vector3(Math.random() * 140 - 70, Math.random() * 100 - 50, Math.random() * 40 - 20).multiplyScalar(scaleFactor));
        }

        class Jellyfish {
            constructor() {
                this.group = new THREE.Group();

                const color = new THREE.Color().setHSL(Math.random(), 0.7 + Math.random() * 0.3, 0.5 + Math.random() * 0.3);
                // Balloon-shaped body using LatheGeometry
                const points = [];
                const segments = 16;
                for (let i = 0; i <= segments; i++) {
                    const t = i / segments;
                    const radius = 5 * scaleFactor * Math.sin(Math.PI * t) * (1 + 0.2 * (1 - t)); // Wider middle, tapered top
                    points.push(new THREE.Vector2(radius, t * 6 * scaleFactor - 3 * scaleFactor)); // -3 to 3 height
                }
                const bodyGeometry = new THREE.LatheGeometry(points, 16);
                const bodyMaterial = new THREE.MeshPhongMaterial({
                    color: color,
                    shininess: 100,
                    transparent: true,
                    opacity: 0.85,
                    emissive: color,
                    emissiveIntensity: 0.5
                });
                this.body = new THREE.Mesh(bodyGeometry, bodyMaterial);
                this.body.rotation.x = Math.PI; // Open downward
                this.body.geometry.computeVertexNormals(); // Baseline normals
                this.body.visible = true; // Ensure visibility
                this.group.add(this.body);

                // Verlet tentacles (unchanged)
                this.tentacles = [];
                const tentacleMaterial = new THREE.LineBasicMaterial({ color: color });
                const numTentacles = 8;
                const tentacleLength = 15 * scaleFactor;
                const numSegments = 10;
                for (let i = 0; i < numTentacles; i++) {
                    const angle = (i / numTentacles) * Math.PI * 2;
                    const attachPos = new THREE.Vector3(Math.cos(angle) * 3 * scaleFactor, -0.1 * scaleFactor, Math.sin(angle) * 3 * scaleFactor);
                    const tentacle = {
                        points: [],
                        line: null
                    };
                    for (let j = 0; j < numSegments; j++) {
                        const p = attachPos.clone().add(new THREE.Vector3(0, -j * (tentacleLength / (numSegments - 1)), 0));
                        tentacle.points.push({ pos: p.clone(), prevPos: p.clone() });
                    }
                    for (let j = 1; j < numSegments; j++) {
                        tentacle.points[j].prevPos.y -= 0.5 * scaleFactor;
                    }
                    const geometry = new THREE.BufferGeometry().setFromPoints(tentacle.points.map(p => p.pos));
                    tentacle.line = new THREE.Line(geometry, tentacleMaterial);
                    this.group.add(tentacle.line);
                    this.tentacles.push(tentacle);
                }

                this.group.position.set(Math.random() * 80 - 40, Math.random() * 80 - 40, Math.random() * 80 - 40).multiplyScalar(scaleFactor);

                this.velocity = new THREE.Vector3();
                this.swimPhase = Math.random() * Math.PI * 2;
                this.targetPos = null;
            }

            update(dt, allJellies, index) {
                if (formationMode) {
                    this.targetPos = formationTargets[index];
                    const dir = this.targetPos.clone().sub(this.group.position).normalize();
                    this.group.position.add(dir.multiplyScalar(20 * dt));
                    this.body.scale.setScalar(1); // Reset scale in formation
                    return;
                }

                this.swimPhase += dt * 1; // Slower pulse

                // Reset if too far
                const distToCenter = this.group.position.length();
                if (distToCenter > 150 * scaleFactor) {
                    this.group.position.set(Math.random() * 80 - 40, Math.random() * 80 - 40, Math.random() * 80 - 40).multiplyScalar(scaleFactor);
                    this.velocity.set(0, 0, 0);
                }

                this.velocity.y += Math.sin(this.swimPhase) * 0.2 * scaleFactor;
                this.velocity.x += Math.cos(this.swimPhase * 0.5) * 0.08 * scaleFactor;
                this.velocity.z += Math.sin(this.swimPhase * 0.3) * 0.08 * scaleFactor;

                this.velocity.multiplyScalar(0.98);

                allJellies.forEach(other => {
                    if (other !== this) {
                        const dist = this.group.position.distanceTo(other.group.position);
                        if (dist < 20 * scaleFactor && dist > 0) {
                            const repelDir = this.group.position.clone().sub(other.group.position).normalize();
                            this.velocity.add(repelDir.multiplyScalar(0.1 / dist * scaleFactor));
                        }
                    }
                });

                const center = new THREE.Vector3(0, 0, 0);
                const pullDir = center.clone().sub(this.group.position).normalize();
                this.velocity.add(pullDir.multiplyScalar(0.005 * scaleFactor)); // Gentle pull

                this.group.position.add(this.velocity.clone().multiplyScalar(dt));

                const bound = 100 * scaleFactor;
                if (Math.abs(this.group.position.x) > bound) {
                    this.group.position.x = Math.sign(this.group.position.x) * bound;
                    this.velocity.x *= -1;
                    this.velocity.add(new THREE.Vector3(Math.random() * 0.2 - 0.1, 0, 0).multiplyScalar(scaleFactor));
                }
                if (Math.abs(this.group.position.y) > bound) {
                    this.group.position.y = Math.sign(this.group.position.y) * bound;
                    this.velocity.y *= -1;
                    this.velocity.add(new THREE.Vector3(0, Math.random() * 0.2 - 0.1, 0).multiplyScalar(scaleFactor));
                }
                if (Math.abs(this.group.position.z) > bound) {
                    this.group.position.z = Math.sign(this.group.position.z) * bound;
                    this.velocity.z *= -1;
                    this.velocity.add(new THREE.Vector3(0, 0, Math.random() * 0.2 - 0.1).multiplyScalar(scaleFactor));
                }

                // Balloon pulse via scale
                const pulse = 1 + Math.abs(Math.sin(this.swimPhase)) * 0.15;
                this.body.scale.set(pulse, pulse * 0.9, pulse); // Slight vertical elongate for balloon vibe

                // Update tentacles with Verlet (unchanged)
                this.tentacles.forEach((tentacle, tIndex) => {
                    const points = tentacle.points;
                    const tentacleLength = 15 * scaleFactor;
                    const segmentLength = tentacleLength / (points.length - 1);

                    // Root attach with velocity lag
                    const angle = (tIndex / this.tentacles.length) * Math.PI * 2;
                    points[0].pos.set(Math.cos(angle) * 3 * scaleFactor, -0.1 * scaleFactor, Math.sin(angle) * 3 * scaleFactor);
                    points[0].prevPos.copy(points[0].pos);

                    // Forces: stronger gravity, less wobble
                    for (let i = 1; i < points.length; i++) {
                        const vel = points[i].pos.clone().sub(points[i].prevPos);
                        vel.multiplyScalar(0.95); // Stronger drag
                        vel.y -= 0.1 * dt * scaleFactor; // Stronger gravity
                        vel.y += 0.02 * dt * scaleFactor; // Light buoyancy
                        vel.x += Math.sin(this.swimPhase + tIndex + i * 0.5) * 0.005 * scaleFactor;
                        vel.z += Math.cos(this.swimPhase + tIndex + i * 0.5) * 0.005 * scaleFactor;
                        points[i].prevPos = points[i].pos.clone();
                        points[i].pos.add(vel);
                    }

                    // Constraints (tighter, more iterations)
                    for (let iter = 0; iter < 15; iter++) {
                        for (let i = 1; i < points.length; i++) {
                            const dir = points[i].pos.clone().sub(points[i - 1].pos);
                            const dist = dir.length();
                            const diff = (dist - segmentLength) / dist;
                            const correction = dir.multiplyScalar(diff * 0.5);
                            points[i].pos.sub(correction);
                            points[i - 1].pos.add(correction);
                        }
                    }

                    tentacle.line.geometry.setFromPoints(points.map(p => p.pos));
                    tentacle.line.geometry.attributes.position.needsUpdate = true;
                });
            }
        }

        for (let i = 0; i < numJellies; i++) {
            const jelly = new Jellyfish();
            scene.add(jelly.group);
            jellyfishes.push(jelly);
        }

        console.log("Scene setup done");

        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();

        function onClick(event) {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);
            const ray = raycaster.ray;

            jellyfishes.forEach(jelly => {
                const point = jelly.group.position;
                const direction = ray.direction.clone().normalize();
                const proj = point.clone().sub(ray.origin).dot(direction);
                const closest = ray.origin.clone().add(direction.multiplyScalar(proj));
                const dist = point.distanceTo(closest);

                if (dist < 20 * scaleFactor) {
                    const dir = point.clone().sub(closest).normalize();
                    jelly.velocity.add(dir.multiplyScalar((20 * scaleFactor - dist) * 1.5 + Math.random() * 10 * scaleFactor));
                }
            });
        }

        document.addEventListener('click', onClick);

        // Long press
        document.addEventListener('touchstart', (e) => { touchStartTime = Date.now(); });
        document.addEventListener('touchend', (e) => {
            if (Date.now() - touchStartTime > 1000) {
                formationMode = !formationMode;
                if (formationMode) formationTimer = formationDuration;
            }
        });
        document.addEventListener('mousedown', (e) => { touchStartTime = Date.now(); });
        document.addEventListener('mouseup', (e) => {
            if (Date.now() - touchStartTime > 1000) {
                formationMode = !formationMode;
                if (formationMode) formationTimer = formationDuration;
            }
        });

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
            waterMaterial.uniforms.resolution.value.set(window.innerWidth, window.innerHeight);
        });

        let lastTime = 0;

        function animate(time) {
            requestAnimationFrame(animate);
            const dt = Math.min((time - lastTime) / 1000, 0.016); // Tighter cap at 60fps
            lastTime = time;

            waterMaterial.uniforms.time.value += dt;
            updateBubbles(dt);

            if (formationMode && formationTimer > 0) {
                formationTimer -= dt;
                if (formationTimer <= 0) {
                    formationMode = false;
                    jellyfishes.forEach(jelly => {
                        jelly.velocity.add(new THREE.Vector3(Math.random() - 0.5, Math.random() - 0.5, Math.random() - 0.5).normalize().multiplyScalar(60 * scaleFactor));
                    });
                }
            }

            jellyfishes.forEach((jelly, index) => jelly.update(dt, jellyfishes, index));

            composer.render();
        }

        animate(0);
        console.log("Animating");
    </script>
</body>
</html>